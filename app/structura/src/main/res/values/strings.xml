<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="app_name">Structura</string>
    <string name="drawer_open">Open navigation drawer</string>
    <string name="drawer_close">Close navigation drawer</string>

    <!-- Landing Page -->
    <string name="landing">Welcome</string>
    <string name="landing_body_txt_1">Welcome to Structura!</string>
    <string name="landing_body_txt_2">Tap around and see what interests you.</string>

    <!-- Navigation drawer sections -->
    <string name="title_linked_list">Linked List</string>
    <string name="title_section2">Section 2</string>
    <string name="title_settings">Settings</string>
    <string name="title_about">About</string>

    <!-- Button text -->
    <string name="add_node_label">Insert</string>
    <string name="delete_node_label">Delete</string>

    <!-- Content Description -->
    <string name="desc_list_item_icon">Item Icon</string>
    <string name="desc_landing_img">Landing Image</string>
    <string name="desc_example">Example action</string>
    <string name="desc_settings">Settings</string>
    <string name="hello_blank_fragment">Hello blank fragment</string>

    <!-- Tab titles -->
    <string name="title_play">Play</string>
    <string name="title_summary">Summary</string>
    <string name="title_quiz">Quiz</string>

    <string name="nodeValue">Value</string>
    <string name="nodeNext">Next</string>
    <string name="nodeValueDigit">0</string>

    <!-- Summaries -->
    <string name="llsummarytext"> <![CDATA[<p>Linked list is a common data structure used in computer science. There are many kinds of linked lists, but we will discuss singly linked lists (SLL) here.</p>
<p>In an SLL, each node is composed of a value ‘data’ and a pointer ‘next’ to the next node in the sequence. This structure allows for efficient insertion or removal of elements from any position in the sequence.</p>
<p>SLL’s can be used to implement several other common abstract data types, including lists (the abstract data type), stacks, queues, associative arrays (dictionaries), etc.</p>
<p>Generally, we also store a pointer ‘head’ which points to the first element of the linked list.</p>
<p>The SLL supports the following operations:</p>
<p> <strong>Insert:</strong> We insert a new node = (d,null) into an SLL. Here, d is its data value and its ‘next’ parameter is null at the moment.</p>
<p>We first make the ‘next’ pointer of this node to point to the current head, and then the head pointer to point to the new node. This way, we insert the node to the front of the SLL. </p>
<p> <strong> Delete: </strong> We take the node as input whose next node has to be deleted. That way, we just set the value of node.next to node.next.next, and destroy node.next.</p>
<p> <strong> Search:  </strong> In order to search the SLL for a value, we start with the head, and loop until the value is found, that is, node.data = value, or return False otherwise. </p>
<p> In each iteration of the loop, we check if the current node’s data is equal to the input value, if it is not, we make the current node equal to current node.next.</p> ]]></string>

</resources>